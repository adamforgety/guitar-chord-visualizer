<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Fretboard Visualizer (Accurate Scales & Intervals)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            height: 100vh;
        }
        .key-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 2px, 4px, 0.06);
        }
        /* Responsive SVG container for mobile */
        #fretboardContainer {
            width: 100%;
            max-width: 340px;
        }
        @media (max-width: 480px) {
            #fretboardContainer {
                max-width: 98vw;
                padding: 0.5rem !important;
            }
            #fretboardSvg {
                height: 180px !important;
            }
        }
        @media (max-width: 640px) {
            #fretboardContainer {
                max-width: 98vw;
            }
        }
    </style>
</head>
<body class="p-1 h-screen flex items-center justify-center">

    <div class="w-full max-w-4xl bg-white rounded-xl shadow-2xl p-4 md:p-6 h-[98%] overflow-y-auto">
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-extrabold text-gray-900 mb-1 text-center">
                Guitar Fretboard Visualizer
            </h1>
            <p class="text-center text-gray-600 text-sm md:text-base">
                Visualize Chords or Scales with accurate note and interval labels.
            </p>
        </header>
        
        <div class="flex justify-center mb-6 max-w-sm mx-auto p-1 bg-transparent rounded-xl gap-2">
            <button id="modeChord" data-mode="chord" class="flex-1 py-3 text-base font-bold rounded-xl transition duration-150 shadow-md border-b-4 border-r-2">Chord Mode</button>
            <button id="modeScale" data-mode="scale" class="flex-1 py-3 text-base font-bold rounded-xl transition duration-150 shadow-md border-b-4 border-r-2">Scale Mode</button>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-6 max-w-2xl mx-auto">
            <div class="space-y-1">
                <label for="rootNote" class="block text-sm font-medium text-gray-700">Root Note</label>
                <select id="rootNote" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                </select>
            </div>
            <div class="space-y-1">
                <label id="typeLabel" for="typeSelector" class="block text-sm font-medium text-gray-700">Chord Type</label>
                <select id="typeSelector" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                </select>
            </div>
            <div class="space-y-1">
                <label id="positionLabel" for="positionSelector" class="block text-sm font-medium text-gray-700">Position / Shape</label>
                <select id="positionSelector" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                </select>
            </div>
        </div>

        <div class="flex flex-col items-center">
            <h2 id="resultName" class="text-xl font-semibold text-gray-800 mb-3 text-center h-6"></h2>
            <p id="messageArea" class="text-red-500 mb-4 h-6 text-center"></p>
            <div id="fretboardContainer" class="relative w-full max-w-md p-2 bg-gray-100 rounded-lg key-shadow">
                <svg id="fretboardSvg" width="100%" height="230" preserveAspectRatio="xMidYMid meet"></svg>
            </div>
            <div id="infoArea" class="mt-4 p-4 w-full max-w-lg bg-white rounded-xl shadow border border-gray-200">
                <div id="intervalLegend" class="text-sm text-gray-700">
                    <h3 class="font-bold mb-2 text-center text-gray-800">Note Function Legend</h3>
                    <div class="flex flex-wrap justify-center gap-x-4 gap-y-2">
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-red-500"></span> Root (R)</span>
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-yellow-400"></span> Third (3 / m3)</span>
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-green-500"></span> Fifth (5)</span>
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-blue-500"></span> Other Chord/Scale Notes</span>
                    </div>
                    <p class="text-xs text-center mt-3 text-gray-500">
                        *Circles display the **Note Name** for direct learning.*
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Core Configuration Data ---
        const NOTE_INFO = [
            { id: 0, name: "C" }, { id: 1, name: "C#" }, { id: 2, name: "D" }, 
            { id: 3, name: "D#" }, { id: 4, name: "E" }, { id: 5, name: "F" }, 
            { id: 6, name: "F#" }, { id: 7, name: "G" }, { id: 8, name: "G#" }, 
            { id: 9, name: "A" }, { id: 10, name: "A#" }, { id: 11, name: "B" }
        ];

        const STRING_TUNING = [4, 9, 2, 7, 11, 4]; 
        
        const CHORD_DEFINITIONS = {
            'major': { name: 'Major', intervals: [0, 4, 7] },
            'minor': { name: 'Minor', intervals: [0, 3, 7] },
            'dom7': { name: '7th', intervals: [0, 4, 7, 10] },
            'min7': { name: 'minor 7th', intervals: [0, 3, 7, 10] },
            'maj7': { name: 'Major 7th', intervals: [0, 4, 7, 11] }, 
            'sus2': { name: 'sus2', intervals: [0, 2, 7] },          
            'sus4': { name: 'sus4', intervals: [0, 5, 7] },          
        };
        const OPEN_CHORDS = { 
            '9_major': { finger: ['X', 0, 2, 2, 2, 0], rootString: 1, name: 'A Major' }, 
            '0_major': { finger: ['X', 3, 2, 0, 1, 0], rootString: 1, name: 'C Major' }, 
            '2_major': { finger: ['X', 'X', 0, 2, 3, 2], rootString: 3, name: 'D Major' },
            '4_major': { finger: [0, 2, 2, 1, 0, 0], rootString: 0, name: 'E Major' },
            '7_major': { finger: [3, 2, 0, 0, 0, 3], rootString: 0, name: 'G Major' },
            '9_minor': { finger: ['X', 0, 2, 2, 1, 0], rootString: 1, name: 'A minor' }, 
            '2_minor': { finger: ['X', 'X', 0, 2, 3, 1], rootString: 3, name: 'D minor' },
            '4_minor': { finger: [0, 2, 2, 0, 0, 0], rootString: 0, name: 'E minor' },
        };
        const SHAPES = {
            'open_position': { name: "Open Position" }, 
            'e_shape': {
                name: "E-Shape (6th String Root)",
                voicings: {
                    'major':    [1, 3, 3, 2, 1, 1], 
                    'minor':    [1, 3, 3, 1, 1, 1], 
                    'dom7':     [1, 3, 2, 2, 1, 1], 
                    'min7':     [1, 3, 1, 2, 1, 1],
                    'maj7':     [1, 3, 2, 3, 4, 1], 
                    'sus2':     [1, 3, 3, 1, 1, 1], 
                    'sus4':     [1, 3, 4, 4, 1, 1], 
                },
                rootStringIndex: 0
            },
            'a_shape': {
                name: "A-Shape (5th String Root)",
                voicings: {
                    'major':    ['X', 1, 3, 3, 3, 1], 
                    'minor':    ['X', 1, 3, 3, 2, 1], 
                    'dom7':     ['X', 1, 3, 2, 3, 1], 
                    'min7':     ['X', 1, 2, 2, 3, 1],
                    'maj7':     ['X', 1, 3, 2, 1, 1], 
                    'sus2':     ['X', 1, 3, 3, 1, 1], 
                    'sus4':     ['X', 1, 3, 3, 4, 1], 
                },
                rootStringIndex: 1
            },
        };
        const SHAPE_ORDER = ['open_position', 'e_shape', 'a_shape'];

        const SCALE_DEFINITIONS = {
            'major': { name: 'Major (Ionian)', intervals: [0, 2, 4, 5, 7, 9, 11] },
            'minor': { name: 'Natural Minor (Aeolian)', intervals: [0, 2, 3, 5, 7, 8, 10] },
            'pentatonic_min': { name: 'Minor Pentatonic', intervals: [0, 3, 5, 7, 10] },
        };

        const SCALE_POSITIONS = [
            { key: 'p1', name: 'Position 1 (Starts Fret 1)', startFret: 1 },
            { key: 'p3', name: 'Position 3 (Starts Fret 3)', startFret: 3 },
            { key: 'p5', name: 'Position 5 (Starts Fret 5)', startFret: 5 },
            { key: 'p7', name: 'Position 7 (Starts Fret 7)', startFret: 7 },
            { key: 'p10', name: 'Position 10 (Starts Fret 10)', startFret: 10 },
        ];

        // --- Fretboard & SVG Configuration ---
        // Make these smaller for mobile!
        const SVG_CONFIG = {
            TOTAL_FRETS: 5,
            TOTAL_STRINGS: 6,
            FRET_HEIGHT: window.innerWidth <= 480 ? 28 : 38,        // Was 50, now 28 for mobile, 38 for desktop/tablet
            STRING_SPACING: window.innerWidth <= 480 ? 30 : 38,     // Was 55, now 30 for mobile, 38 for desktop/tablet
            CHART_START_Y: window.innerWidth <= 480 ? 24 : 32,      // Was 40, now 24 for mobile, 32 for desktop/tablet
            NUT_THICKNESS: 6,       // Slightly thinner nut
            FINGER_RADIUS: window.innerWidth <= 480 ? 9 : 13,       // Was 15, now 9 for mobile, 13 for desktop/tablet
            COLOR_ROOT: '#ef4444',
            COLOR_THIRD: '#facc15',
            COLOR_FIFTH: '#10b981',
            COLOR_OTHER: '#3b82f6',
        };
        
        let modeChordButton;
        let modeScaleButton;
        let rootNoteSelect;
        let typeSelector;
        let positionSelector;
        let typeLabel;
        let positionLabel;
        let resultNameH2;
        let messageAreaP;
        let fretboardSvg;
        let intervalLegendDiv;

        let currentMode = 'chord'; 

        const INACTIVE_COLOR_CLASSES = [
            'bg-white', 'text-gray-800', 'border-gray-400', 'hover:bg-gray-100'
        ];
        const ACTIVE_COLOR_CLASSES = [
            'bg-blue-600', 'text-white', 'border-blue-800', 'shadow-xl'
        ];

        function getNoteName(stringIndex, fret) {
            if (fret === 'X') return '';
            const stringTuningNote = STRING_TUNING[stringIndex];
            const noteIndex = (stringTuningNote + fret) % 12;
            return NOTE_INFO[noteIndex].name;
        }
        function getInterval(rootIndex, noteIndex) {
            return (noteIndex - rootIndex + 12) % 12;
        }
        function getNoteColor(interval) {
            switch (interval) {
                case 0: return SVG_CONFIG.COLOR_ROOT;
                case 3: 
                case 4: 
                    return SVG_CONFIG.COLOR_THIRD;
                case 7: 
                    return SVG_CONFIG.COLOR_FIFTH;
                default:
                    return SVG_CONFIG.COLOR_OTHER;
            }
        }
        function getAbsoluteNoteIndex(stringIndex, fret) {
            if (fret === 'X') return null;
            const stringTuningNote = STRING_TUNING[stringIndex];
            return (stringTuningNote + fret) % 12;
        }

        function toggleButtonStyles(button, isActive) {
            if (isActive) {
                button.classList.remove(...INACTIVE_COLOR_CLASSES);
                button.classList.add(...ACTIVE_COLOR_CLASSES);
            } else {
                button.classList.remove(...ACTIVE_COLOR_CLASSES);
                button.classList.add(...INACTIVE_COLOR_CLASSES);
            }
        }

        function updateMode(newMode) {
            currentMode = newMode;
            toggleButtonStyles(modeChordButton, currentMode === 'chord');
            toggleButtonStyles(modeScaleButton, currentMode === 'scale');
            populateTypeAndPositionSelectors();
            updateVisualization();
        }

        function populateTypeAndPositionSelectors() {
            typeSelector.innerHTML = '';
            positionSelector.innerHTML = '';
            if (currentMode === 'chord') {
                typeLabel.textContent = 'Chord Type';
                positionLabel.textContent = 'Position / Shape';
                typeSelector.innerHTML = Object.entries(CHORD_DEFINITIONS).map(([key, def]) => 
                    `<option value="${key}">${def.name}</option>`
                ).join('');
                positionSelector.innerHTML = SHAPE_ORDER.map(key => 
                    `<option value="${key}">${SHAPES[key].name}</option>`
                ).join('');
                typeSelector.value = 'major';
                positionSelector.value = 'open_position';
            } else {
                typeLabel.textContent = 'Scale Type';
                positionLabel.textContent = 'Fret Start Position';
                typeSelector.innerHTML = Object.entries(SCALE_DEFINITIONS).map(([key, def]) => 
                    `<option value="${key}">${def.name}</option>`
                ).join('');
                positionSelector.innerHTML = SCALE_POSITIONS.map(pos => 
                    `<option value="${pos.startFret}">${pos.name}</option>`
                ).join('');
                typeSelector.value = 'major';
                positionSelector.value = SCALE_POSITIONS[0].startFret;
            }
        }

        function calculateChordFingering(rootIndex, typeKey, shapeKey) {
            const rootNoteName = NOTE_INFO[rootIndex].name;
            const chordDef = CHORD_DEFINITIONS[typeKey];
            const chordTypeName = chordDef.name;
            const chordIntervals = chordDef.intervals;

            if (shapeKey === 'open_position') {
                const lookupKey = `${rootIndex}_${typeKey}`;
                const openChordData = OPEN_CHORDS[lookupKey]; 
                if (!openChordData) {
                    return { error: `No standard ${rootNoteName} ${chordTypeName} found in the Open Position.` };
                }
                const fingering = openChordData.finger.map((fretValue, i) => {
                    if (fretValue === 'X') {
                        return { string: i, fret: 'X', isChordTone: false };
                    }
                    const absoluteNoteIndex = getAbsoluteNoteIndex(i, fretValue);
                    const interval = getInterval(rootIndex, absoluteNoteIndex);
                    const isChordTone = chordIntervals.includes(interval);
                    return { 
                        string: i, 
                        fret: fretValue,
                        isChordTone: isChordTone,
                        noteName: getNoteName(i, fretValue),
                        interval: interval,
                        color: isChordTone ? getNoteColor(interval) : SVG_CONFIG.COLOR_OTHER
                    };
                });
                return { name: `${rootNoteName} ${chordTypeName} (Open Position)`, fingering: fingering, barreFret: null, displayStartFret: 1, stringsToBarre: [], };
            }
            
            const shapeData = SHAPES[shapeKey];
            const fretPattern = shapeData.voicings[typeKey];
            const rootStringIndex = shapeData.rootStringIndex;
            const stringRootNote = STRING_TUNING[rootStringIndex];
            const fretDiff = (rootIndex - stringRootNote + 12) % 12;
            const barreFret = fretDiff === 0 ? 12 : fretDiff; 

            let highestFrettedNote = 0;
            let stringsToBarre = [];
            const fingering = fretPattern.map((patternValue, stringIndex) => {
                if (patternValue === 'X') {
                    return { string: stringIndex, fret: 'X', isChordTone: false };
                }
                const finalFret = barreFret + (patternValue - 1);
                if (finalFret > highestFrettedNote) { highestFrettedNote = finalFret; }
                if (patternValue === 1) { stringsToBarre.push(stringIndex); }
                const absoluteNoteIndex = getAbsoluteNoteIndex(stringIndex, finalFret);
                const interval = getInterval(rootIndex, absoluteNoteIndex);
                const isChordTone = chordIntervals.includes(interval);

                return { 
                    string: stringIndex, 
                    fret: finalFret, 
                    isChordTone: isChordTone,
                    noteName: getNoteName(stringIndex, finalFret),
                    interval: interval,
                    color: isChordTone ? getNoteColor(interval) : SVG_CONFIG.COLOR_OTHER
                };
            });
            const showBarre = (stringsToBarre.length >= 2); 
            let finalDisplayStartFret = 1;
            if (highestFrettedNote > SVG_CONFIG.TOTAL_FRETS) {
                finalDisplayStartFret = Math.max(1, highestFrettedNote - SVG_CONFIG.TOTAL_FRETS + 1);
            }
            return { 
                name: `${rootNoteName} ${chordTypeName} (${shapeData.name} @ ${barreFret}fr)`,
                fingering: fingering,
                barreFret: showBarre ? barreFret : null,
                displayStartFret: finalDisplayStartFret,
                stringsToBarre: showBarre ? stringsToBarre : [],
            };
        }

        function calculateScaleFingering(rootIndex, scaleTypeKey, startFret) {
            const rootNoteName = NOTE_INFO[rootIndex].name;
            const scaleDef = SCALE_DEFINITIONS[scaleTypeKey];
            if (!scaleDef) {
                 return { error: `Scale definition for ${scaleTypeKey} not found.` };
            }
            const displayStartFret = parseInt(startFret);
            const displayEndFret = displayStartFret + SVG_CONFIG.TOTAL_FRETS - 1;
            const fingering = [];
            for (let stringIndex = 0; stringIndex < SVG_CONFIG.TOTAL_STRINGS; stringIndex++) {
                const startFretLoop = displayStartFret === 1 ? 0 : displayStartFret;
                const endFretLoop = displayEndFret;
                for (let fret = startFretLoop; fret <= endFretLoop; fret++) {
                    if (fret === 0 && displayStartFret > 1) continue;
                    const absoluteNoteIndex = getAbsoluteNoteIndex(stringIndex, fret);
                    const interval = getInterval(rootIndex, absoluteNoteIndex);
                    if (scaleDef.intervals.includes(interval)) {
                        const fretToDisplay = fret;
                        if (fretToDisplay === 0 || (fretToDisplay >= displayStartFret && fretToDisplay <= displayEndFret)) {
                            if (!fingering.some(f => f.string === stringIndex && f.fret === fretToDisplay)) {
                                fingering.push({
                                    string: stringIndex,
                                    fret: fretToDisplay,
                                    noteName: NOTE_INFO[absoluteNoteIndex].name,
                                    interval: interval,
                                    color: getNoteColor(interval),
                                });
                            }
                        }
                    }
                }
            }
            let name = `${rootNoteName} ${scaleDef.name}`;
            if (displayStartFret > 1) {
                name += ` (Fret ${displayStartFret} to ${displayEndFret})`;
            } else {
                name += ` (Open Position Map)`;
            }
            return { 
                name: name,
                fingering: fingering,
                barreFret: null, 
                displayStartFret: displayStartFret,
                stringsToBarre: [],
            };
        }

        function drawFretboard(data) {
            const svg = fretboardSvg;
            svg.innerHTML = '';
            const { fingering, barreFret, stringsToBarre, displayStartFret } = data;
            const FRET_H = SVG_CONFIG.FRET_HEIGHT;
            const STRING_SPACING = SVG_CONFIG.STRING_SPACING;
            const TOTAL_STRINGS = SVG_CONFIG.TOTAL_STRINGS;
            const TOTAL_FRETS = SVG_CONFIG.TOTAL_FRETS;
            const FINGER_R = SVG_CONFIG.FINGER_RADIUS;
            const LABEL_AREA_W = 36;
            const STRING_W = (TOTAL_STRINGS - 1) * STRING_SPACING;
            const START_Y = SVG_CONFIG.CHART_START_Y;
            const showNut = (displayStartFret === 1);
            const svgWidth = svg.getBoundingClientRect().width;
            const CHART_FULL_W = STRING_W + LABEL_AREA_W + 10;
            const TRANSLATE_X = Math.max(0, (svgWidth / 2) - (CHART_FULL_W / 2));
            const START_X = LABEL_AREA_W;
            let gContent = '';
            const svgHeight = START_Y + TOTAL_FRETS * FRET_H + 26;
            svg.setAttribute('height', svgHeight);
            if (showNut) {
                gContent += `<rect x="${START_X - 2}" y="${START_Y - SVG_CONFIG.NUT_THICKNESS / 2}" width="${STRING_W + 4}" height="${SVG_CONFIG.NUT_THICKNESS}" fill="#374151"/>`;
            } else {
                gContent += `<line x1="${START_X}" y1="${START_Y}" x2="${START_X + STRING_W}" y2="${START_Y}" stroke="#374151" stroke-width="2" />`;
                gContent += `<text x="${START_X - 18}" y="${START_Y + 7}" text-anchor="end" font-size="12" fill="#374151">${displayStartFret}fr</text>`;
            }
            for (let i = 1; i <= TOTAL_FRETS; i++) {
                const y = START_Y + i * FRET_H;
                gContent += `<line x1="${START_X}" y1="${y}" x2="${START_X + STRING_W}" y2="${y}" stroke="#374151" stroke-width="2" />`;
            }
            for (let i = 0; i < TOTAL_STRINGS; i++) {
                const x = START_X + i * STRING_SPACING;
                const y2 = START_Y + TOTAL_FRETS * FRET_H;
                gContent += `<line x1="${x}" y1="${START_Y}" x2="${x}" y2="${y2}" stroke="#374151" stroke-width="1" />`;
            }
            if (currentMode === 'chord' && barreFret !== null && stringsToBarre.length > 0) {
                const barreFretOffset = barreFret - displayStartFret;
                if (barreFretOffset >= 0 && barreFretOffset < TOTAL_FRETS) {
                    const barreY = START_Y + barreFretOffset * FRET_H + FRET_H / 2;
                    const firstBarreStringX = START_X + stringsToBarre[0] * STRING_SPACING;
                    const lastBarreStringX = START_X + stringsToBarre[stringsToBarre.length - 1] * STRING_SPACING;
                    gContent += `<line x1="${firstBarreStringX}" y1="${barreY}" x2="${lastBarreStringX}" y2="${barreY}" stroke="#3b82f6" stroke-width="8" stroke-linecap="round" opacity="0.6"/>`;
                    gContent += `<text x="${START_X - 22}" y="${barreY + 6}" text-anchor="end" font-size="14" font-weight="bold" fill="#3b82f6">${barreFret}fr</text>`;
                }
            }
            fingering.sort((a, b) => a.fret - b.fret).forEach(f => {
                const stringX = START_X + f.string * STRING_SPACING;
                if (f.fret === 'X') {
                    gContent += `<text x="${stringX}" y="${START_Y - 10}" text-anchor="middle" font-size="16" font-weight="bold" fill="#ef4444">X</text>`;
                } else if (f.fret === 0) {
                    const fill = f.color || 'transparent';
                    const stroke = fill === 'transparent' ? '#374151' : 'none';
                    gContent += `<circle cx="${stringX}" cy="${START_Y - 10}" r="6" fill="${fill}" stroke="${stroke}" stroke-width="2"/>`;
                    const label = f.noteName;
                    const labelColor = fill !== 'transparent' ? 'white' : '#374151';
                    if (label) {
                        const fontSize = (label.length > 1) ? 8 : 10;
                         gContent += `<text x="${stringX}" y="${START_Y - 6}" text-anchor="middle" font-weight="bold" font-size="${fontSize}" fill="${labelColor}">${label}</text>`;
                    }
                } else {
                    const fretNumber = f.fret;
                    const fretOffset = fretNumber - displayStartFret;
                    if (fretOffset >= 0 && fretOffset < TOTAL_FRETS) {
                        const fingerY = START_Y + fretOffset * FRET_H + FRET_H / 2;
                        const fill = f.color || SVG_CONFIG.COLOR_OTHER;
                        const noteText = f.noteName;
                        gContent += `<circle cx="${stringX}" cy="${fingerY}" r="${FINGER_R}" fill="${fill}" class="key-shadow"/>`;
                        const fontSize = (noteText && noteText.length > 1) ? 9 : 11;
                        gContent += `<text x="${stringX}" y="${fingerY + 4}" text-anchor="middle" font-weight="bold" font-size="${fontSize}" fill="white">${noteText}</text>`;
                    }
                }
            });
            // Smaller dot markers
            const dotFrets = [3, 5, 7, 9, 12];
            const dotX = START_X + STRING_W / 2;
            const dotR = 4; 
            dotFrets.forEach(absoluteFret => {
                const fretOffset = absoluteFret - displayStartFret;
                if (fretOffset > 0 && fretOffset <= TOTAL_FRETS) {
                    const markerY = START_Y + fretOffset * FRET_H; 
                    if (absoluteFret % 12 === 0) { 
                        gContent += `<circle cx="${dotX - 12}" cy="${markerY}" r="${dotR}" fill="#cccccc"/>`; 
                        gContent += `<circle cx="${dotX + 12}" cy="${markerY}" r="${dotR}" fill="#cccccc"/>`; 
                    } else if ([3, 5, 7, 9].includes(absoluteFret)) { 
                        gContent += `<circle cx="${dotX}" cy="${markerY}" r="${dotR}" fill="#cccccc"/>`;
                    }
                }
            });
            svg.innerHTML = `<g transform="translate(${TRANSLATE_X}, 0)">${gContent}</g>`;
        }

        function updateVisualization() {
            const rootIndex = parseInt(rootNoteSelect.value);
            const typeKey = typeSelector.value;
            const positionKey = positionSelector.value;
            messageAreaP.textContent = '';
            fretboardSvg.innerHTML = ''; 
            resultNameH2.textContent = '';
            let data;
            if (currentMode === 'chord') {
                data = calculateChordFingering(rootIndex, typeKey, positionKey);
            } else {
                data = calculateScaleFingering(rootIndex, typeKey, positionKey);
            }
            if (data && data.error) {
                const typeName = currentMode === 'chord' ? CHORD_DEFINITIONS[typeKey].name : SCALE_DEFINITIONS[typeKey].name;
                resultNameH2.textContent = `${NOTE_INFO[rootIndex].name} ${typeName}`;
                messageAreaP.textContent = data.error;
                return;
            }
            if (data) {
                resultNameH2.textContent = data.name;
                drawFretboard(data);
            }
        }

        function init() {
            modeChordButton = document.getElementById('modeChord');
            modeScaleButton = document.getElementById('modeScale');
            rootNoteSelect = document.getElementById('rootNote');
            typeSelector = document.getElementById('typeSelector');
            positionSelector = document.getElementById('positionSelector');
            typeLabel = document.getElementById('typeLabel');
            positionLabel = document.getElementById('positionLabel');
            resultNameH2 = document.getElementById('resultName');
            messageAreaP = document.getElementById('messageArea');
            fretboardSvg = document.getElementById('fretboardSvg');
            intervalLegendDiv = document.getElementById('intervalLegend');
            modeChordButton.addEventListener('click', () => updateMode('chord'));
            modeScaleButton.addEventListener('click', () => updateMode('scale'));
            rootNoteSelect.addEventListener('change', updateVisualization);
            typeSelector.addEventListener('change', updateVisualization);
            positionSelector.addEventListener('change', updateVisualization); 
            window.addEventListener('resize', () => {
                // Re-calculate SVG_CONFIG for mobile/desktop on resize
                SVG_CONFIG.FRET_HEIGHT = window.innerWidth <= 480 ? 28 : 38;
                SVG_CONFIG.STRING_SPACING = window.innerWidth <= 480 ? 30 : 38;
                SVG_CONFIG.CHART_START_Y = window.innerWidth <= 480 ? 24 : 32;
                SVG_CONFIG.FINGER_RADIUS = window.innerWidth <= 480 ? 9 : 13;
                updateVisualization();
            });
            rootNoteSelect.innerHTML = NOTE_INFO.map(note => 
                `<option value="${note.id}">${note.name}</option>`
            ).join('');
            rootNoteSelect.value = 4;
            modeChordButton.classList.add(...ACTIVE_COLOR_CLASSES);
            modeScaleButton.classList.add(...INACTIVE_COLOR_CLASSES);
            updateMode('chord');
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
