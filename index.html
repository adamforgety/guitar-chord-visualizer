<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Fretboard Visualizer (Accurate Scales & Intervals)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualizer */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Applied to main containers for depth */
        .key-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 2px, 4px, 0.06);
        }
        /* Ensure the body takes up full height for mobile responsiveness */
        body {
            height: 100vh;
        }
    </style>
</head>
<body class="p-1 h-screen flex items-center justify-center">

    <div class="w-full max-w-4xl bg-white rounded-xl shadow-2xl p-4 md:p-6 h-[98%] overflow-y-auto">
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-extrabold text-gray-900 mb-1 text-center">
                Guitar Fretboard Visualizer
            </h1>
            <p class="text-center text-gray-600 text-sm md:text-base">
                Visualize Chords or Scales with accurate note and interval labels.
            </p>
        </header>
        
        <!-- Mode Switch - Buttons now have the constant 'raised' classes in HTML -->
        <div class="flex justify-center mb-6 max-w-sm mx-auto p-1 bg-transparent rounded-xl gap-2">
            <!-- Chord Button - Initial state will be set by JS in init() -->
            <button id="modeChord" data-mode="chord" class="flex-1 py-3 text-base font-bold rounded-xl transition duration-150 shadow-md border-b-4 border-r-2">Chord Mode</button>
            
            <!-- Scale Button - Initial state will be set by JS in init() -->
            <button id="modeScale" data-mode="scale" class="flex-1 py-3 text-base font-bold rounded-xl transition duration-150 shadow-md border-b-4 border-r-2">Scale Mode</button>
        </div>

        <!-- Selection Controls: 3 Dropdowns for maximum flexibility -->
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-6 max-w-2xl mx-auto">

            <!-- 1. Root Note Selector -->
            <div class="space-y-1">
                <label for="rootNote" class="block text-sm font-medium text-gray-700">Root Note</label>
                <select id="rootNote" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <!-- 2. Type Selector (Chord Type or Scale Type) -->
            <div class="space-y-1">
                <label id="typeLabel" for="typeSelector" class="block text-sm font-medium text-gray-700">Chord Type</label>
                <select id="typeSelector" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                    <!-- Options populated by JS -->
                </select>
            </div>

             <!-- 3. Position/Shape Selector -->
            <div class="space-y-1">
                <label id="positionLabel" for="positionSelector" class="block text-sm font-medium text-gray-700">Position / Shape</label>
                <select id="positionSelector" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                    <!-- Options populated by JS -->
                </select>
            </div>
        </div>

        <!-- Visualization Area -->
        <div class="flex flex-col items-center">
            <h2 id="resultName" class="text-xl font-semibold text-gray-800 mb-3 text-center h-6"></h2>
            
            <!-- Message Area for Chords/Scales that don't exist -->
            <p id="messageArea" class="text-red-500 mb-4 h-6 text-center"></p>
            
            <!-- Fretboard Container: Fixed aspect ratio for vertical chart -->
            <div id="fretboardContainer" class="relative w-full max-w-md p-2 bg-gray-100 rounded-lg key-shadow">
                <svg id="fretboardSvg" width="100%" height="300" preserveAspectRatio="xMidYMid meet"></svg>
            </div>

            <!-- Legend for BOTH Chord and Scale Mode -->
            <div id="infoArea" class="mt-4 p-4 w-full max-w-lg bg-white rounded-xl shadow border border-gray-200">
                <div id="intervalLegend" class="text-sm text-gray-700">
                    <h3 class="font-bold mb-2 text-center text-gray-800">Note Function Legend</h3>
                    <div class="flex flex-wrap justify-center gap-x-4 gap-y-2">
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-red-500"></span> Root (R)</span>
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-yellow-400"></span> Third (3 / m3)</span>
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-green-500"></span> Fifth (5)</span>
                        <span class="flex items-center"><span class="w-3 h-3 rounded-full mr-1 bg-blue-500"></span> Other Chord/Scale Notes</span>
                    </div>
                    <p class="text-xs text-center mt-3 text-gray-500">
                        *Circles display the **Note Name** for direct learning.*
                    </p>
                </div>
            </div>
            
        </div>
    </div>

    <script>
        // --- Core Configuration Data ---
        const NOTE_INFO = [
            { id: 0, name: "C" }, { id: 1, name: "C#" }, { id: 2, name: "D" }, 
            { id: 3, name: "D#" }, { id: 4, name: "E" }, { id: 5, name: "F" }, 
            { id: 6, name: "F#" }, { id: 7, name: "G" }, { id: 8, name: "G#" }, 
            { id: 9, name: "A" }, { id: 10, name: "A#" }, { id: 11, name: "B" }
        ];

        // Standard guitar tuning in semitone indices (E A D G B E)
        const STRING_TUNING = [4, 9, 2, 7, 11, 4]; 
        
        // --- CHORD DATA ---
        const CHORD_DEFINITIONS = {
            'major': { name: 'Major', intervals: [0, 4, 7] },
            'minor': { name: 'Minor', intervals: [0, 3, 7] },
            'dom7': { name: '7th', intervals: [0, 4, 7, 10] },
            'min7': { name: 'minor 7th', intervals: [0, 3, 7, 10] },
            'maj7': { name: 'Major 7th', intervals: [0, 4, 7, 11] }, 
            'sus2': { name: 'sus2', intervals: [0, 2, 7] },          
            'sus4': { name: 'sus4', intervals: [0, 5, 7] },          
        };
        const OPEN_CHORDS = { 
            '9_major': { finger: ['X', 0, 2, 2, 2, 0], rootString: 1, name: 'A Major' }, 
            '0_major': { finger: ['X', 3, 2, 0, 1, 0], rootString: 1, name: 'C Major' }, 
            '2_major': { finger: ['X', 'X', 0, 2, 3, 2], rootString: 3, name: 'D Major' },
            '4_major': { finger: [0, 2, 2, 1, 0, 0], rootString: 0, name: 'E Major' },
            '7_major': { finger: [3, 2, 0, 0, 0, 3], rootString: 0, name: 'G Major' },
            '9_minor': { finger: ['X', 0, 2, 2, 1, 0], rootString: 1, name: 'A minor' }, 
            '2_minor': { finger: ['X', 'X', 0, 2, 3, 1], rootString: 3, name: 'D minor' },
            '4_minor': { finger: [0, 2, 2, 0, 0, 0], rootString: 0, name: 'E minor' },
        };
        const SHAPES = {
            'open_position': { name: "Open Position" }, 
            'e_shape': {
                name: "E-Shape (6th String Root)",
                voicings: {
                    'major':    [1, 3, 3, 2, 1, 1], 
                    'minor':    [1, 3, 3, 1, 1, 1], 
                    'dom7':     [1, 3, 2, 2, 1, 1], 
                    'min7':     [1, 3, 1, 2, 1, 1],
                    'maj7':     [1, 3, 2, 3, 4, 1], 
                    'sus2':     [1, 3, 3, 1, 1, 1], 
                    'sus4':     [1, 3, 4, 4, 1, 1], 
                },
                rootStringIndex: 0
            },
            'a_shape': {
                name: "A-Shape (5th String Root)",
                voicings: {
                    'major':    ['X', 1, 3, 3, 3, 1], 
                    'minor':    ['X', 1, 3, 3, 2, 1], 
                    'dom7':     ['X', 1, 3, 2, 3, 1], 
                    'min7':     ['X', 1, 2, 2, 3, 1],
                    'maj7':     ['X', 1, 3, 2, 1, 1], 
                    'sus2':     ['X', 1, 3, 3, 1, 1], 
                    'sus4':     ['X', 1, 3, 3, 4, 1], 
                },
                rootStringIndex: 1
            },
        };
        const SHAPE_ORDER = ['open_position', 'e_shape', 'a_shape'];

        // --- SCALE DATA ---
        const SCALE_DEFINITIONS = {
            'major': { name: 'Major (Ionian)', intervals: [0, 2, 4, 5, 7, 9, 11] },
            'minor': { name: 'Natural Minor (Aeolian)', intervals: [0, 2, 3, 5, 7, 8, 10] },
            'pentatonic_min': { name: 'Minor Pentatonic', intervals: [0, 3, 5, 7, 10] },
        };

        const SCALE_POSITIONS = [
            { key: 'p1', name: 'Position 1 (Starts Fret 1)', startFret: 1 },
            { key: 'p3', name: 'Position 3 (Starts Fret 3)', startFret: 3 },
            { key: 'p5', name: 'Position 5 (Starts Fret 5)', startFret: 5 },
            { key: 'p7', name: 'Position 7 (Starts Fret 7)', startFret: 7 },
            { key: 'p10', name: 'Position 10 (Starts Fret 10)', startFret: 10 },
        ];

        // --- Fretboard & SVG Configuration ---
        const SVG_CONFIG = {
            TOTAL_FRETS: 5,
            TOTAL_STRINGS: 6,
            FRET_HEIGHT: 50,
            STRING_SPACING: 55,
            CHART_START_Y: 40, 
            NUT_THICKNESS: 8,
            FINGER_RADIUS: 15,
            COLOR_ROOT: '#ef4444',     
            COLOR_THIRD: '#facc15',   
            COLOR_FIFTH: '#10b981',    
            COLOR_OTHER: '#3b82f6',   
        };
        
        // --- DOM Elements & State ---
        let modeChordButton;
        let modeScaleButton;
        let rootNoteSelect;
        let typeSelector;
        let positionSelector;
        let typeLabel;
        let positionLabel;
        let resultNameH2;
        let messageAreaP;
        let fretboardSvg;
        let intervalLegendDiv;

        let currentMode = 'chord'; 

        // Define the color-specific classes for INACTIVE state (raised white/gray)
        const INACTIVE_COLOR_CLASSES = [
            'bg-white', 'text-gray-800', 'border-gray-400', 'hover:bg-gray-100'
        ];
        // Define the color-specific classes for ACTIVE state (raised blue)
        const ACTIVE_COLOR_CLASSES = [
            'bg-blue-600', 'text-white', 'border-blue-800', 'shadow-xl'
        ];

        // --- Helper Functions ---

        function getNoteName(stringIndex, fret) {
            if (fret === 'X') return '';
            const stringTuningNote = STRING_TUNING[stringIndex];
            const noteIndex = (stringTuningNote + fret) % 12;
            return NOTE_INFO[noteIndex].name;
        }
        function getInterval(rootIndex, noteIndex) {
            return (noteIndex - rootIndex + 12) % 12;
        }
        function getNoteColor(interval) {
            switch (interval) {
                case 0: return SVG_CONFIG.COLOR_ROOT;
                case 3: 
                case 4: 
                    return SVG_CONFIG.COLOR_THIRD;
                case 7: 
                    return SVG_CONFIG.COLOR_FIFTH;
                default:
                    return SVG_CONFIG.COLOR_OTHER;
            }
        }
        function getAbsoluteNoteIndex(stringIndex, fret) {
            if (fret === 'X') return null;
            const stringTuningNote = STRING_TUNING[stringIndex];
            return (stringTuningNote + fret) % 12;
        }


        // --- MODE LOGIC ---

        /**
         * Applies or removes the 'raised blue' styles by toggling color classes.
         */
        function toggleButtonStyles(button, isActive) {
            if (isActive) {
                // Activate: Remove inactive colors, add active colors (including a stronger shadow)
                button.classList.remove(...INACTIVE_COLOR_CLASSES);
                button.classList.add(...ACTIVE_COLOR_CLASSES);
            } else {
                // Deactivate: Remove active colors, add inactive colors
                button.classList.remove(...ACTIVE_COLOR_CLASSES);
                button.classList.add(...INACTIVE_COLOR_CLASSES);
            }
        }


        function updateMode(newMode) {
            currentMode = newMode;

            // Apply active/inactive styles
            toggleButtonStyles(modeChordButton, currentMode === 'chord');
            toggleButtonStyles(modeScaleButton, currentMode === 'scale');
            
            // Populate dropdowns based on mode
            populateTypeAndPositionSelectors();
            
            // Run visualization
            updateVisualization();
        }

        function populateTypeAndPositionSelectors() {
            typeSelector.innerHTML = '';
            positionSelector.innerHTML = '';

            if (currentMode === 'chord') {
                typeLabel.textContent = 'Chord Type';
                positionLabel.textContent = 'Position / Shape';
                
                // 2. Chord Types
                typeSelector.innerHTML = Object.entries(CHORD_DEFINITIONS).map(([key, def]) => 
                    `<option value="${key}">${def.name}</option>`
                ).join('');

                // 3. Position/Shapes
                positionSelector.innerHTML = SHAPE_ORDER.map(key => 
                    `<option value="${key}">${SHAPES[key].name}</option>`
                ).join('');

                typeSelector.value = 'major';
                positionSelector.value = 'open_position';
            } else { // Scale mode
                typeLabel.textContent = 'Scale Type';
                positionLabel.textContent = 'Fret Start Position';

                // 2. Scale Types
                typeSelector.innerHTML = Object.entries(SCALE_DEFINITIONS).map(([key, def]) => 
                    `<option value="${key}">${def.name}</option>`
                ).join('');

                // 3. Scale Positions
                positionSelector.innerHTML = SCALE_POSITIONS.map(pos => 
                    `<option value="${pos.startFret}">${pos.name}</option>`
                ).join('');

                typeSelector.value = 'major';
                positionSelector.value = SCALE_POSITIONS[0].startFret;
            }
        }
        
        // --- CHORD CALCULATION LOGIC ---

        function calculateChordFingering(rootIndex, typeKey, shapeKey) {
            const rootNoteName = NOTE_INFO[rootIndex].name;
            const chordDef = CHORD_DEFINITIONS[typeKey];
            const chordTypeName = chordDef.name;
            const chordIntervals = chordDef.intervals;

            if (shapeKey === 'open_position') {
                const lookupKey = `${rootIndex}_${typeKey}`;
                const openChordData = OPEN_CHORDS[lookupKey]; 
                
                if (!openChordData) {
                    return { error: `No standard ${rootNoteName} ${chordTypeName} found in the Open Position.` };
                }
                
                const fingering = openChordData.finger.map((fretValue, i) => {
                    if (fretValue === 'X') {
                        return { string: i, fret: 'X', isChordTone: false };
                    }
                    const absoluteNoteIndex = getAbsoluteNoteIndex(i, fretValue);
                    const interval = getInterval(rootIndex, absoluteNoteIndex);
                    const isChordTone = chordIntervals.includes(interval);
                    
                    return { 
                        string: i, 
                        fret: fretValue,
                        isChordTone: isChordTone,
                        noteName: getNoteName(i, fretValue),
                        interval: interval,
                        color: isChordTone ? getNoteColor(interval) : SVG_CONFIG.COLOR_OTHER
                    };
                });
                return { name: `${rootNoteName} ${chordTypeName} (Open Position)`, fingering: fingering, barreFret: null, displayStartFret: 1, stringsToBarre: [], };
            }
            
            const shapeData = SHAPES[shapeKey];
            const fretPattern = shapeData.voicings[typeKey];
            const rootStringIndex = shapeData.rootStringIndex;
            
            const stringRootNote = STRING_TUNING[rootStringIndex];
            const fretDiff = (rootIndex - stringRootNote + 12) % 12;
            const barreFret = fretDiff === 0 ? 12 : fretDiff; 

            let highestFrettedNote = 0;
            let stringsToBarre = [];

            const fingering = fretPattern.map((patternValue, stringIndex) => {
                if (patternValue === 'X') {
                    return { string: stringIndex, fret: 'X', isChordTone: false };
                }
                const finalFret = barreFret + (patternValue - 1);
                if (finalFret > highestFrettedNote) { highestFrettedNote = finalFret; }
                if (patternValue === 1) { stringsToBarre.push(stringIndex); }
                
                const absoluteNoteIndex = getAbsoluteNoteIndex(stringIndex, finalFret);
                const interval = getInterval(rootIndex, absoluteNoteIndex);
                const isChordTone = chordIntervals.includes(interval);

                return { 
                    string: stringIndex, 
                    fret: finalFret, 
                    isChordTone: isChordTone,
                    noteName: getNoteName(stringIndex, finalFret),
                    interval: interval,
                    color: isChordTone ? getNoteColor(interval) : SVG_CONFIG.COLOR_OTHER
                };
            });
            
            const showBarre = (stringsToBarre.length >= 2); 
            
            let finalDisplayStartFret = 1;
            if (highestFrettedNote > SVG_CONFIG.TOTAL_FRETS) {
                finalDisplayStartFret = Math.max(1, highestFrettedNote - SVG_CONFIG.TOTAL_FRETS + 1);
            }

            return { 
                name: `${rootNoteName} ${chordTypeName} (${shapeData.name} @ ${barreFret}fr)`,
                fingering: fingering,
                barreFret: showBarre ? barreFret : null,
                displayStartFret: finalDisplayStartFret,
                stringsToBarre: showBarre ? stringsToBarre : [],
            };
        }
        
        // --- SCALE CALCULATION LOGIC ---

        function calculateScaleFingering(rootIndex, scaleTypeKey, startFret) {
            const rootNoteName = NOTE_INFO[rootIndex].name;
            const scaleDef = SCALE_DEFINITIONS[scaleTypeKey];
            
            if (!scaleDef) {
                 return { error: `Scale definition for ${scaleTypeKey} not found.` };
            }
            
            const displayStartFret = parseInt(startFret);
            const displayEndFret = displayStartFret + SVG_CONFIG.TOTAL_FRETS - 1;

            const fingering = [];

            for (let stringIndex = 0; stringIndex < SVG_CONFIG.TOTAL_STRINGS; stringIndex++) {
                // If starting at fret 1, we include fret 0 (open string) in the calculation range
                const startFretLoop = displayStartFret === 1 ? 0 : displayStartFret;
                const endFretLoop = displayEndFret;

                for (let fret = startFretLoop; fret <= endFretLoop; fret++) {
                    
                    if (fret === 0 && displayStartFret > 1) continue;
                    
                    const absoluteNoteIndex = getAbsoluteNoteIndex(stringIndex, fret);
                    const interval = getInterval(rootIndex, absoluteNoteIndex);

                    if (scaleDef.intervals.includes(interval)) {
                        
                        const fretToDisplay = fret;
                        
                        // Only display notes that fall within the visible 5-fret window (or are open strings)
                        if (fretToDisplay === 0 || (fretToDisplay >= displayStartFret && fretToDisplay <= displayEndFret)) {
                            if (!fingering.some(f => f.string === stringIndex && f.fret === fretToDisplay)) {
                                fingering.push({
                                    string: stringIndex,
                                    fret: fretToDisplay,
                                    noteName: NOTE_INFO[absoluteNoteIndex].name,
                                    interval: interval,
                                    color: getNoteColor(interval),
                                });
                            }
                        }
                    }
                }
            }

            let name = `${rootNoteName} ${scaleDef.name}`;
            if (displayStartFret > 1) {
                name += ` (Fret ${displayStartFret} to ${displayEndFret})`;
            } else {
                name += ` (Open Position Map)`;
            }

            return { 
                name: name,
                fingering: fingering,
                barreFret: null, 
                displayStartFret: displayStartFret,
                stringsToBarre: [],
            };
        }

        /**
         * Draws the vertical chord/scale diagram using SVG.
         */
        function drawFretboard(data) {
            const svg = fretboardSvg;
            svg.innerHTML = ''; // Clear previous drawing
            
            const { fingering, barreFret, stringsToBarre, displayStartFret } = data;
            
            const FRET_H = SVG_CONFIG.FRET_HEIGHT;
            const STRING_SPACING = SVG_CONFIG.STRING_SPACING;
            const TOTAL_STRINGS = SVG_CONFIG.TOTAL_STRINGS;
            const TOTAL_FRETS = SVG_CONFIG.TOTAL_FRETS;
            const FINGER_R = SVG_CONFIG.FINGER_RADIUS;
            
            const LABEL_AREA_W = 50; 
            const STRING_W = (TOTAL_STRINGS - 1) * STRING_SPACING; 
            const START_Y = SVG_CONFIG.CHART_START_Y; 
            
            // CRITICAL FIX: The Nut should show whenever the chart starts at the 1st fret position (displayStartFret === 1)
            const showNut = (displayStartFret === 1); 

            const svgWidth = svg.getBoundingClientRect().width; 
            const CHART_FULL_W = STRING_W + LABEL_AREA_W + 10; 
            const TRANSLATE_X = Math.max(0, (svgWidth / 2) - (CHART_FULL_W / 2)); 
            const START_X = LABEL_AREA_W; 

            let gContent = '';
            const svgHeight = START_Y + TOTAL_FRETS * FRET_H + 50; 
            svg.setAttribute('height', svgHeight);
            
            // --- 1. Draw Fret Lines (Horizontal) ---

            if (showNut) { // Draw the thick Nut if starting at the 1st fret position, regardless of mode
                // Draw the thick Nut (Fret 0)
                gContent += `<rect x="${START_X - 2}" y="${START_Y - SVG_CONFIG.NUT_THICKNESS / 2}" width="${STRING_W + 4}" height="${SVG_CONFIG.NUT_THICKNESS}" fill="#374151"/>`;
            } else {
                // Draw the start fret line (thin line for fret > 1)
                gContent += `<line x1="${START_X}" y1="${START_Y}" x2="${START_X + STRING_W}" y2="${START_Y}" stroke="#374151" stroke-width="2" />`;
                
                // Fret label for the chart start
                gContent += `<text x="${START_X - 25}" y="${START_Y + 7}" text-anchor="end" font-size="16" fill="#374151">${displayStartFret}fr</text>`;
            }

            // Draw the remaining fret lines (fret 1 to 5)
            for (let i = 1; i <= TOTAL_FRETS; i++) {
                const y = START_Y + i * FRET_H;
                gContent += `<line x1="${START_X}" y1="${y}" x2="${START_X + STRING_W}" y2="${y}" stroke="#374151" stroke-width="2" />`;
            }

            // --- 2. Draw String Lines (Vertical) ---
            for (let i = 0; i < TOTAL_STRINGS; i++) {
                const x = START_X + i * STRING_SPACING;
                const y2 = START_Y + TOTAL_FRETS * FRET_H;
                gContent += `<line x1="${x}" y1="${START_Y}" x2="${x}" y2="${y2}" stroke="#374151" stroke-width="1" />`;
            }

            // --- 3. Draw Barre Line ---
            if (currentMode === 'chord' && barreFret !== null && stringsToBarre.length > 0) {
                const barreFretOffset = barreFret - displayStartFret;
                
                if (barreFretOffset >= 0 && barreFretOffset < TOTAL_FRETS) {
                    const barreY = START_Y + barreFretOffset * FRET_H + FRET_H / 2;
                    const firstBarreStringX = START_X + stringsToBarre[0] * STRING_SPACING;
                    const lastBarreStringX = START_X + stringsToBarre[stringsToBarre.length - 1] * STRING_SPACING;

                    gContent += `<line 
                        x1="${firstBarreStringX}" y1="${barreY}" 
                        x2="${lastBarreStringX}" y2="${barreY}" 
                        stroke="#3b82f6" stroke-width="12" stroke-linecap="round" opacity="0.6"/>`;
                        
                    gContent += `<text 
                        x="${START_X - 30}" 
                        y="${barreY + 6}" 
                        text-anchor="end" 
                        font-size="20" 
                        font-weight="extrabold" 
                        fill="#3b82f6">
                        ${barreFret}fr
                    </text>`;
                }
            }

            // --- 4. Draw Finger Dots (Notes) ---
            fingering.sort((a, b) => a.fret - b.fret).forEach(f => {
                const stringX = START_X + f.string * STRING_SPACING;
                
                if (f.fret === 'X') {
                    gContent += `<text x="${stringX}" y="${START_Y - 10}" text-anchor="middle" font-size="24" font-weight="bold" fill="#ef4444">X</text>`;
                } else if (f.fret === 0) {
                    const fill = f.color || 'transparent';
                    const stroke = fill === 'transparent' ? '#374151' : 'none'; 
                    
                    // Note drawn above the Nut/start line
                    gContent += `<circle cx="${stringX}" cy="${START_Y - 10}" r="8" fill="${fill}" stroke="${stroke}" stroke-width="2"/>`;
                    
                    const label = f.noteName;
                    const labelColor = fill !== 'transparent' ? 'white' : '#374151'; 
                    
                    if (label) {
                        const fontSize = (label.length > 1) ? 10 : 12;
                         gContent += `<text x="${stringX}" y="${START_Y - 6}" text-anchor="middle" font-weight="bold" font-size="${fontSize}" fill="${labelColor}">${label}</text>`;
                    }

                } else {
                    const fretNumber = f.fret;
                    const fretOffset = fretNumber - displayStartFret;
                    
                    if (fretOffset >= 0 && fretOffset < TOTAL_FRETS) {
                        const fingerY = START_Y + fretOffset * FRET_H + FRET_H / 2;
                        
                        const fill = f.color || SVG_CONFIG.COLOR_OTHER;
                        const noteText = f.noteName; 
                        
                        gContent += `<circle cx="${stringX}" cy="${fingerY}" r="${FINGER_R}" fill="${fill}" class="key-shadow"/>`;
                        
                        const fontSize = (noteText && noteText.length > 1) ? 11 : 14; 
                        gContent += `<text x="${stringX}" y="${fingerY + 5}" text-anchor="middle" font-weight="bold" font-size="${fontSize}" fill="white">${noteText}</text>`;
                    }
                }
            });

            // --- 5. Draw Fret Markers (Dots for 3, 5, etc.) ---
            const dotFrets = [3, 5, 7, 9, 12];
            const dotX = START_X + STRING_W / 2;
            const dotR = 6; 

            dotFrets.forEach(absoluteFret => {
                const fretOffset = absoluteFret - displayStartFret;
                
                if (fretOffset > 0 && fretOffset <= TOTAL_FRETS) {
                    const markerY = START_Y + fretOffset * FRET_H; 
                    
                    if (absoluteFret % 12 === 0) { 
                        gContent += `<circle cx="${dotX - 20}" cy="${markerY}" r="${dotR}" fill="#cccccc"/>`; 
                        gContent += `<circle cx="${dotX + 20}" cy="${markerY}" r="${dotR}" fill="#cccccc"/>`; 
                    } else if ([3, 5, 7, 9].includes(absoluteFret)) { 
                        gContent += `<circle cx="${dotX}" cy="${markerY}" r="${dotR}" fill="#cccccc"/>`;
                    }
                }
            });

            svg.innerHTML = `<g transform="translate(${TRANSLATE_X}, 0)">${gContent}</g>`;
        }
        
        /**
         * Main function to update the visualization based on user selection.
         */
        function updateVisualization() {
            const rootIndex = parseInt(rootNoteSelect.value);
            const typeKey = typeSelector.value;
            const positionKey = positionSelector.value;
            
            messageAreaP.textContent = '';
            fretboardSvg.innerHTML = ''; 
            resultNameH2.textContent = '';

            let data;

            if (currentMode === 'chord') {
                data = calculateChordFingering(rootIndex, typeKey, positionKey);
            } else {
                data = calculateScaleFingering(rootIndex, typeKey, positionKey);
            }

            if (data && data.error) {
                const typeName = currentMode === 'chord' ? CHORD_DEFINITIONS[typeKey].name : SCALE_DEFINITIONS[typeKey].name;
                resultNameH2.textContent = `${NOTE_INFO[rootIndex].name} ${typeName}`;
                messageAreaP.textContent = data.error;
                return;
            }

            if (data) {
                resultNameH2.textContent = data.name;
                drawFretboard(data);
            }
        }
        
        /**
         * Initializes all DOM references and sets up event listeners.
         */
        function init() {
            modeChordButton = document.getElementById('modeChord');
            modeScaleButton = document.getElementById('modeScale');
            rootNoteSelect = document.getElementById('rootNote');
            typeSelector = document.getElementById('typeSelector');
            positionSelector = document.getElementById('positionSelector');
            typeLabel = document.getElementById('typeLabel');
            positionLabel = document.getElementById('positionLabel');
            resultNameH2 = document.getElementById('resultName');
            messageAreaP = document.getElementById('messageArea');
            fretboardSvg = document.getElementById('fretboardSvg');
            intervalLegendDiv = document.getElementById('intervalLegend');


            // --- Event Listeners ---
            modeChordButton.addEventListener('click', () => updateMode('chord'));
            modeScaleButton.addEventListener('click', () => updateMode('scale'));

            rootNoteSelect.addEventListener('change', updateVisualization);
            typeSelector.addEventListener('change', updateVisualization);
            positionSelector.addEventListener('change', updateVisualization); 
            window.addEventListener('resize', updateVisualization);

            // --- Initial Load ---
            rootNoteSelect.innerHTML = NOTE_INFO.map(note => 
                `<option value="${note.id}">${note.name}</option>`
            ).join('');
            rootNoteSelect.value = 4; // Default to E for consistency
            
            // Initial button styling setup
            modeChordButton.classList.add(...ACTIVE_COLOR_CLASSES); // Start active
            modeScaleButton.classList.add(...INACTIVE_COLOR_CLASSES); // Start inactive

            // Initial call to set default mode and styling
            updateMode('chord'); 
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
